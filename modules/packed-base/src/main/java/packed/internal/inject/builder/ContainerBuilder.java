/*
 * Copyright (c) 2008 Kasper Nielsen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package packed.internal.inject.builder;

import static java.util.Objects.requireNonNull;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Supplier;

import app.packed.bundle.AnyBundle;
import app.packed.bundle.Bundle;
import app.packed.bundle.BundleLink;
import app.packed.bundle.WiringOption;
import app.packed.config.ConfigSite;
import app.packed.container.ComponentServiceConfiguration;
import app.packed.container.Container;
import app.packed.container.ContainerConfiguration;
import app.packed.inject.Factory;
import app.packed.inject.Injector;
import app.packed.inject.InjectorConfigurator;
import app.packed.inject.InstantiationMode;
import app.packed.inject.ServiceConfiguration;
import app.packed.util.Key;
import app.packed.util.Nullable;
import packed.internal.annotations.AtProvides;
import packed.internal.annotations.AtProvidesGroup;
import packed.internal.box.Box;
import packed.internal.box.BoxServices;
import packed.internal.box.BoxType;
import packed.internal.bundle.AppPackedBundleSupport;
import packed.internal.classscan.ComponentClassDescriptor;
import packed.internal.classscan.ServiceClassDescriptor;
import packed.internal.config.site.ConfigurationSiteType;
import packed.internal.config.site.InternalConfigurationSite;
import packed.internal.container.InternalComponentConfiguration;
import packed.internal.container.InternalContainer;
import packed.internal.inject.AppPackedInjectSupport;
import packed.internal.inject.ServiceNode;
import packed.internal.inject.runtime.InternalInjector;
import packed.internal.invokable.InternalFunction;

/**
 * A builder of {@link Injector injectors}. Is both used via {@link InjectorConfigurator}.
 */
public class ContainerBuilder extends DefaultContainerConfiguration {

    // Maybe should be able to define a namig strategy, to avoid reuse? Mostly for distributed
    // Lazy initialized... Maybe this is part of the Specification/ContainerConfigurationProvider
    final ConcurrentHashMap<String, AtomicLong> autoGeneratedComponentNames = new ConcurrentHashMap<>();

    boolean autoRequires;

    final Box box;

    /** A list of bundle bindings, as we need to post process the exports. */
    ArrayList<BindInjectorFromBundle> injectorBundleBindings;

    InternalInjector privateInjector;

    /** All nodes that have been added to this builder, even those that are not exposed. */
    ServiceBuildNode<?> privateLatestNode;

    InternalInjector publicInjector;

    @Nullable
    final ArrayList<ServiceBuildNodeExported<?>> publicNodeList;

    /** The root component, or null if no root component has been set yet. */
    @Nullable
    public InternalComponentConfiguration<?> root;

    public ContainerBuilder(InternalConfigurationSite configurationSite, @Nullable Bundle bundle, WiringOption... options) {
        super(configurationSite, bundle, options);
        publicNodeList = new ArrayList<>();
        box = new Box(BoxType.INJECTOR_VIA_BUNDLE);
    }

    protected final <T> ServiceBuildNode<T> bindNode(ServiceBuildNode<T> node) {
        assert privateLatestNode == null;
        privateLatestNode = node;
        return node;
    }

    public Container build() {
        // if (root == null) {
        // throw new IllegalStateException("Must install at least one component");
        // }
        for (WiringOption wo : options) {
            AppPackedBundleSupport.invoke().process(wo, new BundleLink() {

                @Override
                public ContainerConfiguration cc() {
                    return ContainerBuilder.this;
                }

                @Override
                public Class<? extends AnyBundle> childType() {
                    throw new UnsupportedOperationException();
                }

                @Override
                public ConfigSite configSite() {
                    return ContainerBuilder.this.configurationSite();
                }

                @Override
                public Mode mode() {
                    throw new UnsupportedOperationException();
                }
            });
        }
        if (root != null) {
            if (root.name == null) {
                root.name = root.descriptor().simpleName;
            }

            // initialize component instance array and set component names.
            root.forEachRecursively(cc -> {
                cc.instances = new Object[1 + (cc.mixins == null ? 0 : cc.mixins.size())];
                // Create a name for all children where no name have been defined
                if (cc.children != null && (cc.childrenExplicitNamed == null || cc.children.size() != cc.childrenExplicitNamed.size())) {
                    if (cc.childrenExplicitNamed == null) {
                        cc.childrenExplicitNamed = new HashMap<>(cc.children.size());
                    }
                    for (InternalComponentConfiguration<?> child : cc.children) {
                        String name = child.descriptor().simpleName;
                        AtomicLong al = autoGeneratedComponentNames.computeIfAbsent(name, ignore -> new AtomicLong());
                        String newName;
                        do {
                            long l = al.getAndIncrement();
                            newName = l == 0 ? name : name + l;
                        } while (cc.childrenExplicitNamed.putIfAbsent(newName, child) != null);
                        child.name = newName;
                    }
                }
            });
        }
        InternalContainer container = new InternalContainer(this, buildInjector());

        return container;
    }

    public Injector buildInjector() {
        freezeLatest();
        freeze();
        new DependencyGraph(this).instantiate();
        return publicInjector;
    }

    /**
     * Exposes the specified key as a service.
     * 
     * @param key
     *            the key of the service that should be exposed
     * @return a configuration for the exposed service
     */
    public final <T> ServiceConfiguration<T> export(Key<T> key) {
        requireNonNull(key, "key is null");
        checkConfigurable();
        freezeLatest();

        InternalConfigurationSite cs = configurationSite().spawnStack(ConfigurationSiteType.BUNDLE_EXPOSE);

        ServiceNode<T> node = box.services().nodes.getRecursive(key);
        if (node == null) {
            throw new IllegalArgumentException("Cannot expose non existing service, key = " + key);
        }
        ServiceBuildNodeExported<T> bn = new ServiceBuildNodeExported<>(this, cs, node);
        bn.as(key);
        publicNodeList.add(bn);
        bindNode(bn);
        return bn;
    }

    @SuppressWarnings("unchecked")
    public final <T> ServiceConfiguration<T> export(ServiceConfiguration<T> configuration) {
        // Skal skrives lidt om, det her burde virke, f.eks. som export(provide(ddd).asNone).as(String.class)

        return (ServiceConfiguration<T>) export(configuration.getKey());
    }

    protected void freezeLatest() {
        // Skal vi egentlig ikke ogsaa frysse noden????
        if (privateLatestNode != null) {
            Key<?> key = privateLatestNode.key();
            if (key != null) {
                if (privateLatestNode instanceof ServiceBuildNodeExported) {
                    box.services().exports.put(privateLatestNode);
                } else {
                    if (!box.services().nodes.putIfAbsent(privateLatestNode)) {
                        System.err.println("OOPS");
                    }
                }
            }

            privateLatestNode.freeze();
            privateLatestNode = null;
        }
    }

    /**
     * Sets the component root iff a root has not already been set.
     *
     * @param configuration
     *            the component configuration
     * @return the specified component configuration
     */
    private <T> InternalComponentConfiguration<T> install0(InternalComponentConfiguration<T> configuration) {
        if (root == null) {
            root = configuration;
        } else {
            if (root.children == null) {
                root.children = new ArrayList<>();
            }
            root.children.add(configuration);
        }

        return configuration;
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    public <T> ComponentServiceConfiguration<T> installService(Factory<T> factory) {
        requireNonNull(factory, "factory is null");
        checkConfigurable();
        freezeLatest();
        InternalFunction<T> func = AppPackedInjectSupport.toInternalFunction(factory);

        ComponentClassDescriptor cdesc = accessor.componentDescriptorFor(func.getReturnTypeRaw());
        InternalComponentConfiguration<T> icc = new InternalComponentConfiguration<T>(this,
                configurationSite().spawnStack(ConfigurationSiteType.COMPONENT_INSTALL), cdesc, root, func, (List) factory.dependencies());
        ComponentServiceConfiguration<T> cc = install0(icc);
        scanForProvides(func.getReturnTypeRaw(), icc);
        bindNode(icc).as(factory.defaultKey());
        return cc;
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    public <T> ComponentServiceConfiguration<T> installService(T instance) {
        requireNonNull(instance, "instance is null");
        checkConfigurable();
        freezeLatest();
        ComponentClassDescriptor cdesc = accessor.componentDescriptorFor(instance.getClass());
        InternalComponentConfiguration<T> icc = new InternalComponentConfiguration<T>(this,
                configurationSite().spawnStack(ConfigurationSiteType.COMPONENT_INSTALL), cdesc, root, instance);
        ComponentServiceConfiguration<T> cc = install0(icc);
        scanForProvides(instance.getClass(), icc);
        bindNode(icc).as((Class) instance.getClass());
        return cc;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public final <T> ServiceConfiguration<T> provide(Factory<T> factory) {
        requireNonNull(factory, "factory is null");
        checkConfigurable();
        freezeLatest();

        InstantiationMode mode = InstantiationMode.SINGLETON;
        InternalConfigurationSite frame = configurationSite().spawnStack(ConfigurationSiteType.INJECTOR_CONFIGURATION_BIND);
        InternalFunction<T> func = AppPackedInjectSupport.toInternalFunction(factory);

        ServiceClassDescriptor serviceDesc = accessor.serviceDescriptorFor(func.getReturnTypeRaw());
        ServiceBuildNodeDefault<T> node = new ServiceBuildNodeDefault<>(this, frame, serviceDesc, mode, accessor.readable(func), (List) factory.dependencies());

        scanForProvides(func.getReturnTypeRaw(), node);

        return bindNode(node).as(factory.defaultKey());
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public final <T> ServiceConfiguration<T> provide(T instance) {
        checkConfigurable();
        freezeLatest();
        ServiceClassDescriptor serviceDesc = accessor.serviceDescriptorFor(instance.getClass());
        ServiceBuildNodeDefault<T> node = new ServiceBuildNodeDefault<>(this, configurationSite().spawnStack(ConfigurationSiteType.INJECTOR_CONFIGURATION_BIND),
                serviceDesc, instance);
        scanForProvides(instance.getClass(), node);
        return bindNode(node).as((Class) instance.getClass());
    }

    public void registerStatics(Class<?> staticsHolder) {
        throw new UnsupportedOperationException();
    }

    protected void scanForProvides(Class<?> type, ServiceBuildNodeDefault<?> owner) {
        AtProvidesGroup provides = accessor.serviceDescriptorFor(type).provides;
        if (!provides.members.isEmpty()) {
            owner.hasInstanceMembers = provides.hasInstanceMembers;
            // if (owner.instantiationMode() == InstantiationMode.PROTOTYPE && provides.hasInstanceMembers) {
            // throw new InvalidDeclarationException("Cannot @Provides instance members form on services that are registered as
            // prototypes");
            // }

            // First check that we do not have existing services with any of the provided keys
            for (Key<?> k : provides.members.keySet()) {
                if (box.services().nodes.containsKey(k)) {
                    throw new IllegalArgumentException("At service with key " + k + " has already been registered");
                }
            }

            // AtProvidesGroup has already validated that the specified type does not have any members that provide services with
            // the same key, so we can just add them now without any verification
            for (AtProvides member : provides.members.values()) {
                box.services().nodes.put(owner.provide(member));// put them directly
            }
        }
    }

    public final void serviceAutoRequire() {
        autoRequires = true;
    }

    public BoxServices services() {
        return box.services();
    }

    public void wireInjector(Bundle bundle, WiringOption... stages) {
        requireNonNull(bundle, "bundle is null");
        List<WiringOption> listOfStages = AppPackedBundleSupport.invoke().extractWiringOperations(stages, Bundle.class);
        checkConfigurable();
        freezeLatest();
        InternalConfigurationSite cs = configurationSite().spawnStack(ConfigurationSiteType.INJECTOR_CONFIGURATION_INJECTOR_BIND);
        BindInjectorFromBundle is = new BindInjectorFromBundle(this, cs, bundle, listOfStages);
        is.processImport();
        if (injectorBundleBindings == null) {
            injectorBundleBindings = new ArrayList<>(1);
        }
        injectorBundleBindings.add(is);
    }

    public final void provideAll(Injector injector, WiringOption... operations) {
        requireNonNull(injector, "injector is null");
        checkConfigurable();
        freezeLatest();
        InternalConfigurationSite cs = configurationSite().spawnStack(ConfigurationSiteType.INJECTOR_CONFIGURATION_INJECTOR_BIND);
        ProvideAllFromInjector pa = new ProvideAllFromInjector(cs, injector, this, operations);
        pa.importServices();
    }

    /** Small for utility class for generate a best effort unique name for containers. */
    static class InternalContainerNameGenerator {

        /** Assigns unique IDs, starting with 1 when lazy naming containers. */
        private static final AtomicLong ANONYMOUS_ID = new AtomicLong();

        private static final ClassValue<Supplier<String>> BUNDLE_NAME_SUPPLIER = new ClassValue<>() {
            private final AtomicLong L = new AtomicLong();

            @Override
            protected Supplier<String> computeValue(Class<?> type) {
                String simpleName = type.getSimpleName();
                String s = simpleName.endsWith("Bundle") && simpleName.length() > 6 ? simpleName.substring(simpleName.length() - 6) : simpleName;
                return () -> s + L.incrementAndGet();
            }
        };

        static String fromBundleType(Class<? extends Bundle> cl) {
            return BUNDLE_NAME_SUPPLIER.get(cl).get();
        }

        static String next() {
            return "Container" + ANONYMOUS_ID.incrementAndGet();
        }
    }
}
